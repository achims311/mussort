#!/usr/bin/perl
# mussort - a simple program for sorting music collections
# Copyright (C) Eskild Hustvedt 2007, 2008, 2009
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;
use File::Find;
use File::Basename qw(dirname basename);
use File::Path qw(rmtree);
use File::Copy;
use Getopt::Long;
use IPC::Open2;
use Cwd qw(realpath);
use Storable;
use constant { 
	true => 1, 
	false => 0,

	# Verbosity levels
	M_STANDARD => 1,
	M_VERBOSE => 2,
	M_VERYVERBOSE => 3,
	M_DEBUG => 4,

	# Directory types, used for getDirectoriesIn()
	DIR_TYPE_PRIMARY => 1,
	DIR_TYPE_SECONDARY => 2,
};

our $VERSION = 0.2;

# Hash of which information sources we have
my %Has = (
	'Audio::File' => false,
	'id3v2' => false,
	'id3info' => false,
	'ogginfo' => false,
);

# Dir hash, used for the final directory cleanup
my %cleanTree;
# Dir preferance hash, used for case-insensitive searches
my %DirPreferance;
# The file information cache (as used by --cache)
my %cachedInfo;
# The directory information cache
my @dirInfoCache;

# -- The following are altered through command-line parameters --
# Bool, true if we should never remove any files
my $NeverRemove = false;
# Bool, true if we should prefer Audio::File over the other programs
my $PreferAudioFile = false;
# Verbosity level (0-4)
my $verbosity = 1;
# Bool, true if we should remove the largest file
my $RemoveLargest = true;
# Bool, true if we should allow special characters in file names
my $AllowSpecialChars = false;
# Bool, true if we should work in case-insensitive mode
my $DirInsensitive = false;
# Bool, true if we should silently skip files (not outputting information about it)
my $SilentSkip = false;
# Bool, true if we should 
my $CompilationDetection;
# Bool, true or a string if caching is enabled (string would be path to the cache file)
my $cacheFile = false;
# Bool, true if we should add all directories to the clean process
my $addAllCleanTree = false;

# This makes sure the children are slayed properly
$SIG{CHLD} = sub {
	my $PID = wait;
       	return(1)
};

# Purpose: Set the title of the xterm/screen
# Usage: setTermTitle(TITLE);
sub setTermTitle
{
	return if not $verbosity > 0;
	return if not defined $ENV{TERM};
	my $title = shift;
	if ($ENV{TERM} =~ /screen/)
	{
		print "\033k$title\033\\";
	}
	else
	{
		print "\033]0;$title\007";
	}
}

# Purpose: Returns the mtime of a file
# Usage: $mtime = mtime(file);
# Note: It returns zero (not undef) if it can't read the mtime
sub mtime
{
	my $file = shift;
	my $mtime;
	(undef,undef,undef,undef,undef,undef,undef,undef,undef,$mtime,undef,undef,undef) = stat($file);
	if(not defined $mtime)
	{
		printv(M_DEBUG,'Failed to read mtime from file '.$file."\n");
		return 0;
	}
	return $mtime;
}

# Purpose: Internal mkpath() that also modifies the directory cache
# Usage: intMkpath(/path/to/create);
sub intMkpath
{
	my $fullpath = shift;
	if (-d $fullpath)
	{
		return;
	}
	my @pathsToCreate;
	$fullpath=~ s{/+$}{};
	while(not -d $fullpath)
	{
		unshift(@pathsToCreate,$fullpath);
		$fullpath = dirname($fullpath);
	}

	foreach my $dir (@pathsToCreate)
	{
		mkdir($dir) or die('Failed to mkdir('.$dir.'): '.$!);
		my $parent = dirname($dir);
		foreach my $type (DIR_TYPE_PRIMARY,DIR_TYPE_SECONDARY)
		{
			if(defined $dirInfoCache[$type]->{$parent})
			{
				push(@{$dirInfoCache[$type]->{$parent}},basename($dir));
				@{$dirInfoCache[$type]->{$parent}} = sort(@{$dirInfoCache[$type]->{$parent}});
			}
		}
	}
}

# Purpose: Check for a dependency
# Usage: CheckDep(COMMAND);
sub CheckDep
{
	my $cmd = shift;
	my $alternate = shift;
	my $warningOnly = shift;
	if(not InPath($cmd))
	{
		my $debPackages = {
				id3info => 'libid3-dev',
				id3v2 => 'id3v2',
				ogginfo => 'vorbis-tools',
				'Audio::File' => 'libaudio-file-perl',
			};
		# Multi-dimensional hash mapping distro -> command -> package
		my %DepToPackage = (
			'/etc/apt/apt.conf.d/01ubuntu' => $debPackages,
			'/etc/debian_version' => $debPackages,
			'/etc/mandriva-release' => {
				ogginfo => 'vorbis-tools',
				id3info => 'id3lib',
				id3v2 => 'id3v2',
			},
			'/etc/fedora-release' => {
				ogginfo => 'vorbis-tools',
				id3info => 'id3lib',
				id3v2 => 'id3v2',
			},
		);
		my $err;
		foreach my $path (keys(%DepToPackage))
		{
			if (-e $path)
			{
				if ($DepToPackage{$path}{$cmd})
				{
					$err = "The command '$cmd' is missing. Please install the $DepToPackage{$path}{$cmd} package.";
					if ($alternate)
					{
						$err .= "\nAlternatively, you may install the $alternate perl module (which is faster).";
						if ($DepToPackage{$path}{$alternate})
						{
							$err .= "\nIt can be found in the $DepToPackage{$path}{$alternate} package.";
						}
					}
				}
			}
		}
		if(not $err)
		{
			$err = "The command '$cmd' is missing. Please install it, then re-run mussort.";
			if ($alternate)
			{
				$err .= "\nAlternatively, you may install the $alternate perl module (which is faster).";
			}
		}
		if ($warningOnly)
		{
			$err =~ s/, then re-run mussort\.//g;
			$err =~ s/Please install /For optimal file format support, please install /g;
			$err .= ' (note that most files will still get sorted fine without it)'."\n";
			warn('Warning: '.$err);
			return false;
		}
		else
		{
			FatalError($err);
		}
	}
	else
	{
		$Has{$cmd} = true;
	}
	return true;
}

# Purpose: Output an error message
# Usage: Error(MESSAGE);
sub Error
{
	warn "Error: $_[0]\n";
}

# Purpose: Output a fatal error message (causes die())
# Usage: FatalError(MESSAGE);
sub FatalError
{
	die "Error: $_[0]\n";
}

# Purpose: Check if a directory is empty
# Usage: DirIsEmpty(PATH);
#  Returns 1 if it is empty, 0 if it isn't.
sub DirIsEmpty
{
	my $dir = shift;
	return 0 if not $dir;
	opendir(TESTDIR, $dir);
	my @TestDir = readdir(TESTDIR);
	closedir(TESTDIR);
	if(not scalar @TestDir > 2)
	{
		return 1;
	}
	return 0;
}

# Purpose: Get information about an ogg vorbis file using ogginfo
# Usage: my %Info = GetOggVorbisInfo(FILE);
sub GetOggVorbisInfo
{
	my $InfoFile = shift;
	$InfoFile = realpath($InfoFile);
	my %Information = ();
	local *STDERR;
	open(STDERR,'>','/dev/null');
	my $PID = open2(my $Child_OUT, my $Child_IN, 'ogginfo', $InfoFile) or FatalError("Unable to open2(): $!\n");
	my $hadInfo = false;
	while(<$Child_OUT>)
	{
		next if not m/=/;
		chomp;
		s/^\s+//g;
		my $Opt = $_;
		my $Val = $_;
		$Opt =~ s/^\s*(.*)\s*=.*/$1/;
		$Opt =~ tr[a-z][A-Z];
		$Val =~ s/^.*=\s*(.*)\s*/$1/;
		if($Val =~ /\S/)
		{
			if(not $Opt eq 'TRACKNUMBER')
			{
				$hadInfo = true;
			}
			$Information{$Opt} = $Val;
		}
	}
	close($Child_OUT);
	close($Child_IN);
	$Information{TRACKNUMBER} =~ s#/.*##;
	if ($hadInfo)
	{
		my %FileInfo;
		$FileInfo{Title} = getTag(\%Information,'title');
		$FileInfo{Band} = getTag(\%Information,'artist');
		$FileInfo{Album} = getTag(\%Information,'album');
		$FileInfo{Track} = getTag(\%Information,'track');
		$FileInfo{Ext} = 'ogg';
		return %FileInfo;
	}
	elsif ($Has{'Audio::File'})
	{
		return GetInfoFromAudioFile($InfoFile);
	}
}

# Purpose: Get information about an mp3 file
# Usage: my %Info = GetMP3Info(FILE);
sub GetMP3Info
{
	my $InfoFile = shift;
	my $hadInfo = false;
	my $Information;
	if ($Has{id3v2})
	{
		($hadInfo,$Information) = GetMP3Info_id3v2($InfoFile);
	}

	if(not $hadInfo and $Has{id3info})
	{
		($hadInfo,$Information) = GetMP3Info_id3info($InfoFile);
	}

	if ($hadInfo)
	{
		my %FileInfo;
		$FileInfo{Title} = getTag($Information,'title');
		$FileInfo{Band} = getTag($Information,'artist');
		$FileInfo{Album} = getTag($Information,'album');
		$FileInfo{Track} = getTag($Information,'track');
		$FileInfo{Ext} = 'mp3';
		return(%FileInfo);
	}
	elsif ($Has{'Audio::File'})
	{
		return GetInfoFromAudioFile($InfoFile);
	}
	return;
}

# Purpose: Fetch tag values from extracted data
# Usage: value = getTag(infoHashRef, tagName);
sub getTag
{
	my $info = shift;
	my $tag = shift;
	my %possibleTags = (
		title => [ 'TIT2','TT2','TITLE' ],
		artist => [ 'TPE1','TP1','ARTIST' ],
		album => [ 'TALB','TAL','ALBUM' ],
		track => [ 'TRCK','TRK','TRACKNUMER', 'TRACK' ],
	);
	if(not defined $possibleTags{$tag})
	{
		warn("Tried to fetch tag '$tag', but it wasn't found in possibleTags");
		return;
	}
	my $content = 'Unknown';
	foreach my $possible (@{$possibleTags{$tag}})
	{
		if(defined $info->{$possible} and length($info->{$possible}) and not $info->{$possible} eq 'Unknown')
		{
			$content = $info->{$possible};
			last;
		}
	}
	if ($tag eq 'track')
	{
		$content =~ s{/.*}{}g;
	}
	return CleanTag($content);
}

# Purpose: Get information from cache if caching is enabled
# Usage: %info = getInfoFromCache(FILE);
sub getInfoFromCache
{
	my $file = shift;
	if(defined $cacheFile)
	{
		if(defined($cachedInfo{mtime}->{$file}))
		{
			if (mtime($file) <= $cachedInfo{mtime}->{$file})
			{
				return $cachedInfo{info}->{$file};
			}
		}
	}
	return;
}

# Purpose: Add information to the cache if caching is enabled
# Usage: addToCache($file,\%info);
sub addToCache
{
	my $file = shift;
	my $info = shift;

	if(defined $cachedInfo{mtime} && defined $cachedInfo{mtime}->{$file})
	{
		if ($cachedInfo{mtime}->{$file} >= mtime($file))
		{
			return;
		}
		else
		{
			printv(M_DEBUG,'Re-evaluating cached information for '.$file."\n");
		}
	}

	if(not defined $cachedInfo{info})
	{
		$cachedInfo{info} = {};
	}
	if(not defined $cachedInfo{mtime})
	{
		$cachedInfo{mtime} = {};
	}

	$cachedInfo{info}->{$file} = $info;
	my $fileinfo = mtime($file);
	if(not $fileinfo)
	{
		printv(M_VERYVERBOSE,'Failed to stat() '.$fileinfo.' - skipping adding it to the cache'."\n");
		delete($cachedInfo{info}->{$file});
	}
	else
	{
		$cachedInfo{mtime}->{$file} = $fileinfo;
	}
}

# Purpose: Rename a file in the cache
# Usage: cacheRename($oldName,$newName);
sub cacheRename
{
	my $oldFile = shift;
	if(not defined $cachedInfo{info} or not defined $cachedInfo{info}->{$oldFile})
	{
		return;
	}
	my $newFile = shift;
	addToCache($newFile,$cachedInfo{info}->{$oldFile});
	delete($cachedInfo{mtime}->{$oldFile});
	delete($cachedInfo{mtime}->{$newFile});
}

# Purpose: Load cached information
# Usage: loadCache();
sub loadCache
{
	printv(M_DEBUG,'Caching is enabled'."\n");
	if(not defined $ENV{HOME})
	{
		die('The environment variable HOME is not set. Unable to continue. Either set HOME, supply an absolute path to --cache or disable --cache'."\n");
	}
	$cacheFile = $ENV{HOME}.'/.mussort-cache';
	if (-e $cacheFile)
	{
		my $iFile = $cacheFile;
		$iFile =~ s{^$ENV{HOME}/*}{~};
		printv(M_STANDARD,'Using cache from '.$cacheFile."\n");
		my $info = retrieve($cacheFile) or FatalError('Failed to retrieve() cache from '.$cacheFile.': '.$!);
		if ($info && ref($info) eq 'HASH')
		{
			printv(M_DEBUG,"Read cached information\n");
			%cachedInfo = %{$info};
		}
		elsif(ref($info))
		{
			FatalError('retrieve() returned a useless reference of type: '.ref($info).' - try to disable --cache'."\n");
		}
	}
}

# Purpose: Write the cache if there is data in it
# Usage: writeCache();
sub writeCache
{
	if(defined($cachedInfo{info}) && keys(%{$cachedInfo{info}}))
	{
		my $had = 1;
		if (-e $cacheFile)
		{
			printv(M_VERBOSE,'Writing updated cache to '.$cacheFile."\n");
		}
		else
		{
			$had = 0;
			printv(M_STANDARD,'Writing cache file '.$cacheFile.'...');
		}
		store(\%cachedInfo,$cacheFile) or FatalError('Failed to store() cache in '.$cacheFile.': '.$!);
		if(not $had)
		{
			printv(M_STANDARD,'done'."\n");
		}
	}
}

# Purpose: Get information about an mp3 file using id3v2
# Usage: my ($hasInfo, $info) = GetMP3Info_id3v2(FILE);
sub GetMP3Info_id3v2
{
	my $InfoFile = shift;
	my %Information = ();
	my $PID = open2(my $Child_OUT, my $Child_IN, 'id3v2', '--list', $InfoFile) or FatalError("Unable to open2(): $!");
	my $hadInfo = false;
	while(<$Child_OUT>)
	{
		next if not /\):/;
		chomp;
		my $Opt = $_;
		my $Val = $_;
		$Opt =~ s/^(\w+)\s.*/$1/g;
		$Val =~ s/^.+\):\s(.+)$/$1/g;
		if($Val =~ /\S/)
		{
			if(not $Opt eq 'TRCK')
			{
				$hadInfo = true;
			}
			$Information{$Opt} = $Val;
		}
	}
	close($Child_OUT);
	close($Child_IN);
	return($hadInfo,\%Information);
}

# Purpose: Get information about an mp3 file using id3info
# Usage: my ($hasInfo, $info) = GetMP3Info_id3info(FILE);
sub GetMP3Info_id3info
{
	my $InfoFile = shift;
	my %Information = ();
	my $PID = open2(my $Child_OUT, my $Child_IN, 'id3info', $InfoFile) or FatalError("Unable to open2(): $!");
	my $hadInfo = false;
	while(<$Child_OUT>)
	{
		next if not /^==/;
		chomp;
		my $Opt = $_;
		my $Val = $_;
		$Opt =~ s/^===\s(\w+)\s.*/$1/g;
		$Val =~ s/^.+\):\s(.+)$/$1/g;
		if($Val =~ /\S/)
		{
			if(not $Opt =~ /^TRC?K$/)
			{
				$hadInfo = true;
			}
			$Information{$Opt} = $Val;
		}
	}
	close($Child_OUT);
	close($Child_IN);
	return($hadInfo,\%Information);
}

# Purpose: Get information about an audio file using Audio::File
# Usage: my %Info = GetInfoFromAudioFile(FILE);
sub GetInfoFromAudioFile
{
	my $File = shift;
	my %FileInfo;
	eval {
		local *STDERR;
		# Audio::File outputs junk to STDERR we don't want, so temporarily redirect it
		# to the black hole
		open(STDERR,'>','/dev/null');
		my $af = Audio::File->new($File);
		eval { $FileInfo{Title} = CleanTag($af->tag->title) };
		eval { $FileInfo{Band} = CleanTag($af->tag->artist) };
		eval { $FileInfo{Album} = CleanTag($af->tag->album) };
		eval { $FileInfo{Track} = CleanTag($af->tag->track) };
		1;
	} or do {
		my $err = $@;
		if(InPath('ogginfo'))
		{
			warn('Audio::File appears to have crashed for this file, using ogginfo for it instead. Error: '.$err);
			return GetInfo($File,true);
		}
		else
		{
			die($err);
		}
	};
	if ($File =~ /mp3$/i)
	{
		$FileInfo{Ext} = 'mp3';
	}
	elsif($File =~ /ogg$/i)
	{
		$FileInfo{Ext} = 'ogg';
	}
	else
	{
		FatalError("Unknown filetype: $File\n");
	}
	return %FileInfo;
}

# Purpose: Get information about a file
# Usage: $FileInfo = GetInfo(pathtofile);
sub GetInfo
{
	my $File = shift;
	my $forceNoAudioFile = shift;
	my %FileInfo;
	# We only use Audio::File for OGGs. id3info appears to be faster
	# for MP3s
	if(my $info = getInfoFromCache($File))
	{
		printv(M_DEBUG,'Using cached information for '.$File."\n");
		%FileInfo = %{$info};
	}
	else
	{
		printv(M_VERYVERBOSE,'Reading information about file: '.$File."\n");
		if (not $forceNoAudioFile and $Has{'Audio::File'} and ($PreferAudioFile or $File =~ /ogg$/i))
		{
			%FileInfo = GetInfoFromAudioFile($File);
		}
		elsif($File =~ /mp3$/i)
		{
			%FileInfo = GetMP3Info($File);
		}
		elsif ($File =~ /ogg$/i)
		{
			%FileInfo = GetOggVorbisInfo($File);
		}
		else
		{
			FatalError("Unknown filetype: $File\n");
		}
	}

	addToCache($File,\%FileInfo);

	if ($CompilationDetection and defined $FileInfo{Album})
	{
		if(not defined $CompilationDetection->{album}->{$FileInfo{Album}}->{$FileInfo{Band}})
		{
			$CompilationDetection->{album}->{$FileInfo{Album}}->{$FileInfo{Band}} = [];
		}
		push(@{$CompilationDetection->{album}->{$FileInfo{Album}}->{$FileInfo{Band}}},$File);
	}

	# If we couldn't extract a track then try to extract it from the filename instead
	if(not defined $FileInfo{Track} or not $FileInfo{Track} =~ /^\d+$/)
	{
		my $Track = basename($File);
		if ($Track =~ s/^(\d+).*$/$1/)
		{
			$FileInfo{Track} = $Track;
		}
	}
	return(\%FileInfo);
}

# Purpose: Strip stuff we don't want in file/dir names
# Usage: my $NewVar = CleanTag(OldVar);
sub CleanTag
{
	my $Name = shift;
	# Make & into and
	$Name =~ s/\&/and/;
	# Don't allow whitespace
	$Name =~ s/\s+/_/g;
	# Remove these characters - if present
	$Name =~ s/~//g;
	$Name =~ s/('|"|\(|\))+//g;
	$Name =~ s#/##g;
	$Name =~ s/\?//g;
	$Name =~ s/#//g;
	# Ensure we don't have two identical _ or - following each other. That's ugly.
	$Name =~ s/_+/_/g;
	$Name =~ s/-+/-/g;
	# Don't begin a file with .
	$Name =~ s/^\.+//;
	# Don't end or begin a file with _ or -
	$Name =~ s/(_|-)+$//;
	$Name =~ s/^(_|-)+//;
	# If we have more than 3 . after each other, force only three
	$Name =~ s/\.\.\.\.+/.../g;
	# Clean up non-ascii characters
	if(not $AllowSpecialChars) {
		# These usually doesn't work, but having them here doesn't hurt
		$Name =~ s/æ/ae/gi;
		$Name =~ s/ø/oe/gi;
		$Name =~ s/å/aa/gi;
		# Now remove everything that doesn't match this regex
		$Name =~ s/[^\w\s\.,-_]//g;
	}
	# Don't let it start with a dot
	$Name =~ s/^\.+//;
	# Don't allow _-_ - just use one -
	$Name =~ s/_-_/-/;
	# Finally, return the cleaned filename
	return($Name);
}

# Purpose: Get the new filename for the file
# Usage: my $NewFileName = GetNewFileName(InfoHash);
sub GetNewFileName
{
	my $Info = shift;
	my $Compilation = shift;
	if (IsInvalidTagValue($Info->{Title}) or IsInvalidTagValue($Info->{Band}))
	{
		return;
	}
	my $NewName = $Info->{Band}.'-'.$Info->{Title}.'.'.$Info->{Ext};
	if(not $Info->{Track} eq 'Unknown' and not $Info->{Track} =~ /\D/)
	{
		if(not $Info->{Track} =~ /\d\d/)
		{
			$Info->{Track} = "0$Info->{Track}";
		}
		# Disallow 00/0
		if($Info->{Track} > 0 )
		{
			$NewName = "$Info->{Track}-$NewName";
		}
	}

	return($NewName);
}

# Purpose: Check that the tag supplied is valid
# Usage: bool = IsInvalidTagValue(VALUE);
# Returns false if it is valid, true if it isn't.
sub IsInvalidTagValue
{
	my $value = shift;
	if(not defined $value
			or not length $value
			or $value eq 'Unknown')
	{
		return true;
	}
	return false;
}

# Purpose: Get a list of directories in a directory - possibly cached
# Usage: array = getDirectoriesIn(directory,type);
sub getDirectoriesIn
{
	my $dir = shift;
	my $type = shift;

	if(not defined $dir or not defined $type)
	{
		die;
	}

	if(not defined $dirInfoCache[$type])
	{
		$dirInfoCache[$type] = {};
	}

	if(defined $dirInfoCache[$type]->{$dir})
	{
		return @{$dirInfoCache[$type]->{$dir}};
	}

	if(not $type eq DIR_TYPE_PRIMARY)
	{
		$dirInfoCache[$type] = {};
	}

	opendir(my $dirHandle,$dir);
	my @dirs;
	foreach(readdir($dirHandle))
	{
		next if not -d $_;
		push(@dirs,$_);
	}
	@dirs = sort(@dirs);
	$dirInfoCache[$type]->{$dir} = \@dirs;
	return @dirs;
}

# Purpose: Get the new directory path for the file
# Usage: my $NewDirName = GetNewDirName(InfoHash);
sub GetNewDirName
{
	my $Info = shift;
	my $BaseDir = shift;
	my $Compilation = shift;
	
	if(IsInvalidTagValue($Info->{Band}))
	{
		return;
	}
	
	my $FirstDir;
	my $SecondDir;
	if ($Compilation)
	{
		if(IsInvalidTagValue($Info->{Album}))
		{
			return;
		}
		$FirstDir = $Info->{Album};
		$SecondDir = '';
	}
	else
	{
		$FirstDir = $Info->{Band};
		$SecondDir = $Info->{Album};
	}
	
	# Get lowercased and fixed name
	my $lowerFirst = lc($FirstDir);
	$lowerFirst =~ s/[\.\,\&]//g;
	my $lowerSecond = lc($SecondDir);
	$lowerSecond =~ s/[\.\,\&]//g;
	if($DirInsensitive)
	{
		if($DirPreferance{$lowerFirst})
		{
			$FirstDir = $DirPreferance{$lowerFirst};
			if($DirPreferance{$lowerSecond})
			{
				$SecondDir = $DirPreferance{$lowerSecond};
			}
		}
		else
		{
			my @dirList = getDirectoriesIn($BaseDir,DIR_TYPE_PRIMARY);
			my $alternateFirst;
			foreach(@dirList)
			{
				if(/^\Q$FirstDir\E/i)
				{
					$FirstDir = $_;
					$alternateFirst = undef;
					last;
				}
				elsif(not $alternateFirst)
				{
					my $TestDir = $FirstDir;
					$TestDir =~ s/(-|_)+//g;
					my $TestThis = $_;
					$TestThis =~ s/(-|_)+//g;
					if($TestThis =~ /^\Q$TestDir\E$/i)
					{
						$alternateFirst = $_;
					}
				}
			}
			if ($alternateFirst)
			{
				$FirstDir = $alternateFirst;
			}
			if(defined $SecondDir and length $SecondDir and -d $BaseDir . '/' . $FirstDir)
			{
				my $alternateSecondary;
				@dirList = getDirectoriesIn($BaseDir.'/'.$FirstDir,DIR_TYPE_SECONDARY);
				foreach(@dirList)
				{
					if(/^\Q$SecondDir\E$/i)
					{
						$SecondDir = $_;
						$alternateSecondary = undef;
						last;
					}
					else
					{
						my $TestDir = $SecondDir;
						$TestDir =~ s/(-|_)+//g;
						my $TestThis = $_;
						$TestThis =~ s/(-|_)+//g;
						if($TestThis =~ /^\Q$TestDir\E$/i)
						{
							$alternateSecondary = $_;
						}
					}
				}
				if ($alternateSecondary)
				{
					$SecondDir = $alternateSecondary;
				}
			}
			$DirPreferance{$lowerFirst} = $FirstDir;
			if(defined $lowerSecond and length $lowerSecond)
			{
				$DirPreferance{$lowerSecond} = $SecondDir;
			}
		}
	}

	if(defined $SecondDir and length $SecondDir and not $SecondDir eq 'Unknown')
	{
		return("$BaseDir/$FirstDir/$SecondDir/");
	}
	else
	{
		return("$BaseDir/$FirstDir/");
	}
}

# Purpose: Do the actual renaming
# Usage: RenameFile(Original name, New Name, BaseDir);
sub RenameFile
{
	my $OrigFile = shift;
	my $NewFile = shift;
	my $BaseDir = shift;
	
	# Get some prettier names to display
	my $OutputOldName = $OrigFile;
	my $OutputNewName = $NewFile;
	$OutputOldName =~ s/^\Q$BaseDir\E\/*//;
	$OutputOldName =~ s#/+#/#g;
	$OutputNewName =~ s/^\Q$BaseDir\E\/*//;
	$OutputNewName =~ s#/+#/#g;
	my $Directory = dirname($NewFile);

	if(($OutputOldName eq $OutputNewName) or ($NewFile eq $OrigFile))
	{
		return;
	}
	# If it exists and isn't a directory then just return
	if(-e $Directory and not -d $Directory)
	{
		return;
	}
	# If the length of the filename is less than 7 just return
	if(length(basename($NewFile)) < 7)
	{
		return;
	}
	# Create the dir
	eval { 
		intMkpath(dirname($NewFile));
		1;
	} 
		or do
	{
		FatalError('Failed to create path' . dirname($NewFile) . ": $@\nWas processing $OrigFile");
	};
	# Check if the file already exists
	if(-e $NewFile)
	{
		# Check which file is the largest
		if(-s $NewFile > -s $OrigFile)
		{
			return if not $RemoveLargest;
			return if $NeverRemove;
			printv(M_STANDARD,"Remove: $OrigFile\n");
			unlink($OrigFile);
			$cleanTree{dirname($OrigFile)} = 1;
			return;
		}
	}
	# Output info and do the actual renaming
	printv(M_STANDARD,"Rename: $OutputOldName -> $OutputNewName\n");
	move($OrigFile,$NewFile) or FatalError("Unable to move $OrigFile to $NewFile: $!");
	cacheRename($OrigFile,$NewFile);
	$cleanTree{dirname($OrigFile)} = 1;
}

# Purpose: Queue a file for renaming
# Usage: QueueRename(Original name, New Name, BaseDir);
sub QueueRename
{
	my $OrigFile = shift;
	my $NewFile = shift;
	my $BaseDir = shift;
	return if ($OrigFile eq $NewFile);
	$CompilationDetection->{fileMap}{$OrigFile} = {
		newFile => $NewFile,
		baseDir => $BaseDir,
	};
}

# Purpose: Remove the supplied directory and up to two directories below it in the tree.
# Usage: RemoveIfEmpty(DIR);
sub RemoveIfEmpty
{
	return if $NeverRemove;
	my $Dir = shift;
	my $SecondDir = dirname($Dir);
	my $ThirdDir = dirname($SecondDir);
	my $Removed;
	foreach($Dir,$SecondDir,$ThirdDir)
	{
		if(not -d $_ or not DirIsEmpty($_))
		{
			last;
		}
		rmdir($_) or Error "Unable to remove $Dir: $!";
		$Removed = $_;
	}
	if($Removed)
	{
		printv(M_STANDARD,"Removed: $Removed\n");
	}
}

# Purpose: Process a file
# Usage: ProcessFile(FILE);
sub ProcessFile
{
	my $File = shift;
	my $BaseDir = shift;
	if (-d $File)
	{
		printv(M_VERBOSE,'Searching through directory '.$File."\n");
		if ($addAllCleanTree)
		{
			$cleanTree{$File} = 1;
		}
		return;
	}
	return if not $File =~ /\.(ogg|mp3)$/gi;
	# It might be a dangling symlink, if it is then just silently skip it
	return if not -e $File;
	my($NewName,$NewDir) = getNewFilePath($File,$BaseDir);
	return if not defined $NewName or not defined $NewDir;
	if ($CompilationDetection)
	{
		QueueRename($File,"$NewDir/$NewName",$BaseDir);
	}
	else
	{
		RenameFile($File,"$NewDir/$NewName",$BaseDir);
	}
}

# Purpose: Get the new dir path and filenames for a file
# Usage: my($NewName,$NewDir) = getNewFilePath($File,$BaseDir,Compilation?);
sub getNewFilePath
{
	my($File,$BaseDir,$Compilation) = @_;
	# Get info
	my $FileInfo = GetInfo($File);
	# Build a new filename for the music file
	my $NewName = GetNewFileName($FileInfo,$Compilation);
	my $NewDir = GetNewDirName($FileInfo,$BaseDir,$Compilation);
	if(not defined($NewName))
	{
		if(not $SilentSkip)
		{
			printv(M_STANDARD,"Skipped: $File\n");
		}
		return;
	}
	my $DirInfo = dirname($File);
	$DirInfo =~ s/^\Q$BaseDir\E//;
	$NewDir = $NewDir ? $NewDir : dirname($File);
	return($NewName,$NewDir);
}

# Purpose: Process pending compilation actions in $CompilationDetection
# Usage: ProcessCompilation();
sub ProcessCompilation
{
	my $BaseDir = shift;

	my $compilationAlbums = [];
	my @compilationRename;

	printv(M_VERBOSE,'Detecting compilation albums...');
	foreach my $album (keys(%{$CompilationDetection->{album}}))
	{
		next if IsInvalidTagValue($album);

		my $thisAlbum = $CompilationDetection->{album}->{$album};
		if (not keys(%{$thisAlbum}) > 2)
		{
			next;
		}

		foreach my $artist (keys(%{$thisAlbum}))
		{
			if(@{$thisAlbum->{$artist}} > 2)
			{
				next;
			}
		}

		my @files;
		foreach my $artist (keys %{$thisAlbum})
		{
			foreach my $file (@{$thisAlbum->{$artist}})
			{
				push(@files,$file);
				if ($CompilationDetection->{fileMap} and $CompilationDetection->{fileMap}->{$file})
				{
					delete($CompilationDetection->{fileMap}->{$file});
				}
			}
		}
		push(@compilationRename,{
				files => \@files,
				album => $album,
			});
	}

	printv(M_VERBOSE,"done\n");

	foreach my $compilationRef (@compilationRename)
	{
		my $compilation = $compilationRef->{files};
		printv(M_STANDARD,"Detected compilation album: $compilationRef->{album}\n");
		foreach my $File (@{$compilation})
		{
			# Build a new filename for the music file
			my($NewName,$NewDir) = getNewFilePath($File,$BaseDir,true);
			next if not defined $NewDir or not defined $NewName;
			RenameFile($File,$NewDir.'/'.$NewName,$BaseDir);
		}
	}

	# Finally, rename those left in fileMap
	if ($CompilationDetection->{fileMap})
	{
		foreach my $file (sort keys %{$CompilationDetection->{fileMap}})
		{
			RenameFile($file,
				$CompilationDetection->{fileMap}->{$file}->{newFile},
				$CompilationDetection->{fileMap}->{$file}->{baseDir},
			);
		}
	}

	# Reset it for the next dir
	$CompilationDetection = {};
}

# Purpose: Sort files
# Usage: sort sortFiles @_
sub sortFiles
{
	if (-d $a and not -d $b)
	{
		return 1;
	}
	elsif(-d $b and not -d $a)
	{
		return -1;
	}
	return $a cmp $b;
}

# Purpose: Traverse a tree
# Usage: ProcessTree(DIR);
sub ProcessTree
{
	my $Dir = shift;
	setTermTitle('mussort ['.$Dir.']');
	$Dir = realpath($Dir);

	printv(M_STANDARD,"Processing: $Dir\n");
	find({
			wanted => sub { ProcessFile($File::Find::name,$Dir); },
			preprocess => sub { return sort sortFiles	@_ },
		},
		$Dir
	);
	if ($CompilationDetection)
	{
		ProcessCompilation($Dir);
	}

	printv(M_VERBOSE,'Looking for empty directories that should be removed...'."\n");
	foreach my $cleanDir (sort keys %cleanTree)
	{
		RemoveIfEmpty($cleanDir);
	}
	return(1);
}

# Purpose: Output information useful for debugging
# Usage: debugInfo();
sub debugInfo
{
	eval('use Digest::MD5; use IPC::Open3;');

	my $format = '%-16s: %s'."\n";
	printf($format,'mussort version',$VERSION);

	# Get ogginfo/i3info versions
	my($id3ver,$id3v2ver,$oggver) = ('missing','missing','missing');

	if(InPath('id3info'))
	{
		open3(my $in, my $out,my $err, 'id3info','-V');
		$id3ver = <$out>;
		$id3ver =~ s/^\D+\d?\D+//;
		chomp($id3ver);
	}

	if(InPath('ogginfo'))
	{
		# --meh isn't a valid command-line parameter, but older versions doesn't have -V,
		# but to an invalid parameter (--meh) it will give us a version number we can regex
		# out
		open3(my $in, my $out, my $err, 'ogginfo','--meh');
		local $/ = undef;
		$oggver = <$out>;
		$oggver =~ s/^\D+//;
		$oggver =~ s/\n.*//g;
		chomp($oggver);
	}

	if(InPath('id3v2'))
	{
		open3(my $in, my $out,my $err, 'id3v2','--version');
		$id3v2ver = <$out>;
		$id3v2ver =~ s/^\s*id3v2\s*//;
		chomp($id3v2ver);
	}

	printf($format,'ogginfo version',$oggver);
	printf($format,'id3info version',$id3ver);
	printf($format,'id3v2 version',$id3v2ver);
	if(eval('use Audio::File;1;'))
	{
		printf($format,'Audio::File',$Audio::File::VERSION);
	}
	else
	{
		printf($format,'Audio::File','missing');
	}

	my $md5 = Digest::MD5->new();
	my $loc = realpath($0);
	open(my $f,'<',$loc);
	$md5->addfile($f);
	my $digest = $md5->hexdigest;
	close($f);
	printf($format,'MD5:',$digest);
	exit(0);
}

# Purpose: Print formatted --help output
# Usage: PrintHelp('-shortoption', '--longoption', 'description');
#  Description will be reformatted to fit within a normal terminal
sub PrintHelp
{
	# The short option
	my $short = shift,
	# The long option
	my $long = shift;
	# The description
	my $desc = shift;
	# The generated description that will be printed in the end
	my $GeneratedDesc;
	# The current line of the description
	my $currdesc = '';
	# The maximum length any line can be
	my $maxlen = 80;
	# The length the options take up
	my $optionlen = 20;
	# Check if the short/long are LONGER than optionlen, if so, we need
	# to do some additional magic to take up only $maxlen.
	# The +1 here is because we always add a space between them, no matter what
	if ((length($short) + length($long) + 1) > $optionlen)
	{
		$optionlen = length($short) + length($long) + 1;
	}
	# Split the description into lines
	foreach my $part (split(/ /,$desc))
	{
		if(defined $GeneratedDesc)
		{
			if ((length($currdesc) + length($part) + 1 + 20) > $maxlen)
			{
				$GeneratedDesc .= "\n";
				$currdesc = '';
			}
			else
			{
				$currdesc .= ' ';
				$GeneratedDesc .= ' ';
			}
		}
		$currdesc .= $part;
		$GeneratedDesc .= $part;
	}
	# Something went wrong
	die('Option mismatch') if not $GeneratedDesc;
	# Print it all
	foreach my $description (split(/\n/,$GeneratedDesc))
	{
		printf "%-4s %-15s %s\n", $short,$long,$description;
		# Set short and long to '' to ensure we don't print the options twice
		$short = '';$long = '';
	}
	# Succeed
	return true;
}

# Purpose: Print a message if verbosity level matches
# Usage: printv(VERBOSITY_LEVEL,message);
sub printv
{
	my $level = shift;
	if ($level > $verbosity)
	{
		return;
	}
	if ($level == M_DEBUG)
	{
		print 'Debug: ';
	}
	print $_[0];
}

# Purpose: Check for a file in path
# Usage: InPath(FILE)
sub InPath
{
	foreach (split /:/, $ENV{PATH}) { if (-x "$_/@_" and not -d "$_/@_" ) {	return 1; } } return 0;
}

# Purpose: Main application
sub main
{
	if(eval('use Audio::File;1;'))
	{
		$Has{'Audio::File'} = 1;
		# id3info isn't strictly required if we have Audio::File
		CheckDep('id3info',undef,true);
	}
	else
	{
		CheckDep('ogginfo','Audio::File');
		CheckDep('id3info');
	}
	CheckDep('id3v2',undef,true);

	if($NeverRemove)
	{
		$RemoveLargest = 0;
	}

	# This only gets printed if debug output actually IS enabled.
	printv(M_DEBUG,"Debug output is enabled\n");

	if(not (@ARGV))
	{
		FatalError('Requires one option: the directory to process. See --help for more information');
	}
	if(defined($cacheFile))
	{
		loadCache();
	}
	else
	{
		printv(M_DEBUG,"Cache file did not exist - not loading\n");
	}
	foreach(@ARGV)
	{
		ProcessTree($_);
	}
	if (defined $cacheFile)
	{
		writeCache();
	}
	exit(0);
}

Getopt::Long::Configure ('bundling');
GetOptions (
	'help|h' => sub {
		print "mussort version $VERSION\n\n";
		print 'Usage: ' . basename($0) . " [OPTIONS] dir1 dir2 ..\n";
		PrintHelp('-h','--help','Display this help screen');
		PrintHelp('','--version','Display version information');
		PrintHelp('-l','--largest','When hitting two files with identical names leave the largest file in place and remove the smallest (default)');
		PrintHelp('-n','--noremove','Never remove any files (overrides --largest)');
		PrintHelp('-a','--allowspecial','Allow special letters (accents and other non-ASCII letters)');
		PrintHelp('-i','--insensitive','Do case insensitive searches for directory names. This will make directory names more consistent but is also a bit slower');
		PrintHelp('','--prefer-audiofile','Prefer to use Audio::File for reading tags from all files (not just OGG vorbis)');
		PrintHelp('-c','--compilation','Enable compilation detection (see the manpage)');
		PrintHelp('','--silentskip','Supress messages about files skipped');
		PrintHelp('-v','--verbose','Increase verbosity. Supply it twice to increase it further');
		PrintHelp('-e','--cache','Enable file information caching');
		PrintHelp('','--quiet','Suppress all non-error messages');
		PrintHelp('','--cleantree','Attempt to clean up the directory tree. This has a significant performance impact. See the manpage for more information');
		exit(0);
	},
	'prefer-audiofile|preferaudiofile' => \$PreferAudioFile,
	'n|noremove' => \$NeverRemove,
	'l|largest' => \$RemoveLargest,
	'i|insensitive' => \$DirInsensitive,
	'a|allowspecial' => \$AllowSpecialChars,
	'debuginfo' => \&debugInfo,
	'c|compilation' => sub { $CompilationDetection = {} },
	'e|cache' => \$cacheFile,
	'v|verbose+' => \$verbosity,
	'q|quiet' => sub { $verbosity = 0 },
	'cleantree' => $addAllCleanTree,
	'version' => sub {
		print "mussort version $VERSION\n";
		exit(0);
	},
	'silentskip' => \$SilentSkip,
) or die('See ' . basename($0) . " --help for more information\n");

main();
__END__

=head1 NAME

mussort - A simple music file sorting program

=head1 SYNOPSIS

mussort I<[OPTIONS]> I<dir1 dir2 ..>

=head1 DESCRIPTION

This is a simple tool that sorts a music collection.

It recursively searches a directory for MP3 and OGG Vorbis files, processing
them one by one. It then reads the information from the file and puts them into
a newly sorted directory tree, in the form
I<base_directory/ARTIST/ALBUM/FILENAME>.  The files are renamed to
I<TRACKNUMBER-ARTIST-TRACKNAME.EXT>, where TRACKNUMBER is omitted if it isn't
found.

If you use --compilation then the sorting will differ for those albums that are
detected to be compilation albums, those will be sorted as
I<base_directory/ALBUM/FILENAME> instead.

mussort will remove directories that end up empty after sorting.

=head1 OPTIONS

=over

=item B<-h, --help>

Display a short help screen and exit

=item B<--version>

Display version information and exit

=item B<-l, --largest>

When mussort reaches two files with identical names, it will remove (delete) the smallest
file and leave the largest in place. This is default.

=item B<-n, --noremove>

When mussort reaches two files with identical names it will ignore one of the
files (the last one it sees) and not sort it.

=item B<-i, --insensitive>

Makes mussort do case-insensitive searches for directory names. This is useful
when the case in the name of an artist differs and makes mussort place all the
music correctly into one directory. This I<might> be a bit slower than normal
operation, but not much. You can combine this option with I<--compilation> if
you want to.

=item B<-a, --allowspecial>

This forces mussort to not strip special characters from file and directory
names.

=item B<-c, --compilation>

Enables compilation detection. In this mode mussort will go through all files
without moving them first, sorting them in an internal data structure, then it
will attempt to detect compilation albums and re-sort members of the
compilation albums before finally moving files on-disk. Compilation albums
are placed into a directory tree matching I<ALBUM/FILENAME> instead of
I<ARTIST/ALBUM/FILENAME>.

Note that this mode is a bit slower than normal mode, and it will take a bit
longer before any actual changes are done. This is because it needs to search
through all files before it can start to rename them.

=item B<--silentskip>

Makes mussort not output messages about files that it skips (those that are skipped
are generally badly tagged, or not tagged at all).

=item B<-v, --verbose>

Increases the verbosity of mussort. Supply twice to further increase verbosity.

If supplied once, extra information about what mussort is doing, such as which
directory is being processed, will be output (this can be useful in --compilation
mode, as --compilation won't output anything until after all files have been read).

If supplied twice, it will also output information about which file is currently
being read.

=item B<--quiet>

Suppresses all status messages (and the terminal title). Errors will still get
printed.

=item B<-e, --cache>

Enables caching of file information. This can greatly improve the runtime speed
of mussort, as it will cache information between runs. Cached information gets
re-read if the file has been modified since the cache was created.

=item B<--cleantree>

When this parameter is in effect, mussort will attempt to clean up the
directory tree by removing all empty directories that it hits (in addition to
performing its usual sorting). Note that this has a rather significant
performance impact because mussort needs to do a lot of extra readdir()
operations, and should only be done if you notice a lot of empty directories in
your music tree and want them cleaned up.

Normally mussort will automatically clean directories that are empty as a
result of sorting, but this option will make it check all directories it finds.

=back

=head1 DEPENDENCIES

It needs id3info from id3lib and either the perl module Audio::File (fastest) or
ogginfo from vorbis-tools (slower) to get file information.

=head1 FILES

=over

=item ~/.mussort-cache

The mussort file information cache. Only created when --cache is used.
You can safely remove this file any time if you want to.

=back

=head1 BUGS AND LIMITATIONS

It does not support other formats than MP3 and Ogg vorbis at this time, however
support for other formats is possible in the future.

If you find a bug, please report it at L<http://random.zerodogg.org/mussort/bugs>.

=head1 INCOMPATIBILITIES

None known.

=head1 AUTHOR

B<mussort> is written by Eskild Hustvedt I<<eskild -at- zerodogg d.ot org>>

=head1 LICENSE AND COPYRIGHT

Copyright (C) Eskild Hustvedt 2007, 2008, 2009

This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
